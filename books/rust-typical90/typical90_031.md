---
title: "031 - VS AtCoder（★6）"
---

[031 \- VS AtCoder（★6）](https://atcoder.jp/contests/typical90/tasks/typical90_ae)


# アルゴリズム

実装に使う状態遷移だけ紹介します。詳細は他のサイトや鉄則本をどうぞ。

## Grundy 数 / 山 1つ、白石なしの場合

青石 `b` が2個以上のときに、青石を半分以下 `1..=(b / 2)` だけ減らすことができます。

このときの Grundy 数の状態遷移を考えます。この状態数は MEX 「同じ状態数にはならない最小の数字」 とします。

青が 0, 1 個のときは、もうなにも操作できません。状態数の初期値 0 を入れます

|白\青|0|1|2|3|4|5|6|7|
|---|---|---|---|---|---|---|---|---|
|[0]|🔍<br>→0||||||||

|白\青|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
|[0]|0|🔍<br>→0||||||||

青が 2 個のときは 1個減らせます。1個減らした状態数は `0` です。`0` でない一番小さな数字 `1` を、青 2個の状態数とします。

|白\青|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
|[0]|0|🚶0|🔍<br>→1||||||

これを繰り返します。

|白\青|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
|[0]|0|0|🚶1|🔍<br>→0||||||
|[0]|0|0|🚶1|🚶0|🔍<br>→2|||||
|[0]|0|0|1|🚶0|🚶2|🔍<br>→1||||
|[0]|0|0|1|🚶0|🚶2|🚶1|🔍<br>→3|||
|[0]|0|0|1|0|🚶2|🚶1|🚶3|🔍<br>→0||
|[0]|0|0|1|0|🚶2|🚶1|🚶3|🚶0|🔍<br>→4|

状態数 0 は「負け」を表します。状態数 0 から 状態数 0 には 1手では移れません。でも 2手では必ず移れます。相手が次の状態数を 0 にするように打てば、石の数が 0, 1 になって手詰まりです。「7(0) → 6(3) → 3(0) → 2(1) → 1(0)」 のように。

最大 `N` 個の青石があるとき、次のように更新するイメージです。

```rust
const N: usize = 50;
let mut grundy = vec![N + 1];
let mut mex = vec![false; N + 1];
for k in 1..=(b / 2) {
    mex[grundy[b - k]] = true;
}
grundy[b] = mex.iter().position(|&x| !x).unwrap();
```

### Grundy 数 /山 1つ、白石ありの場合

白石がある場合、青石を白石の数だけ加え、白石を1つ除くことができます。また状態遷移を書きます。

|白\青|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
|[0]|0|🚶0|1|0|2|1|3|0|4|
|[1]|🔍<br>→1|||||||||

|白\青|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
|[0]|0|0|🚶1|0|2|1|3|0|4|
|[1]|1|🔍<br>→0||||||||

|白\青|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
|[0]|0|0|1|🚶0|2|1|3|0|4|
|[1]|1|🚶0|🔍<br>→1|||||||

:

|白\青|0|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|---|---|
|[0]|0|0|1|0|2|1|3|0|4|
|[1]|1|0|1|0|🚶2|🚶1|🚶3|🚶0|🔍<br>→4|

上の行を見るようになりましたが、行うことはあまり変わりません。

青の個数は前回は最大 50 個でした。白が 50 個あり、初手から青に変え続けると (50 + 49 + ... + 1) 個青が増えます。青の配列サイズはその分増えます。

次のように更新するイメージです:

```rust
const N: usize = 50;
let b_max = N * (N + 1) / 2 + N + 1;
let mut grundy = vec![vec![0; b_max]; N + 1];

for w in 0..=N {
    for b in 0..b_max {
        let mut mex = vec![false; b_max];
        if w >= 1 && b + w < b_max {
            mex[grundy[w - 1][b + w]] = true;
        }
        if b >= 2 {
            for k in 1..=(b / 2) {
                mex[grundy[w][b - k]] = true;
            }
        }
        grundy[w][b] = mex.iter().position(|&x| x).unwrap();
    }
}
```

白石 50個で青石 51個以上はあり得ません。上の配列で不要なところまで計算をしていることが気になるなら、次のように範囲を狭めても良いです。

```rust
const N: usize = 50;
let mut grundy = vec![vec![]; N + 1];
grundy[N] = vec![0usize; N + 1];
for i in (1..=N).rev() {
    let len = grundy[i].len() + i;
    grundy[i - 1] = vec![0usize; len];
}
```

## Grundy 数 / 山が複数の場合

山が複数の場合は、各山の Grundy 数の xor を取ります。

```rust
let xor = std::iter::zip(w, b).fold(0, |acc, (w, b)| acc ^ grundy[w][b]);
let yes = xor != 0;
println!("{}", if yes { "First" } else { "Second" });
```

# 実装例

## Grundy 数 / 二次元配列
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/031_grundy.rs

## Grundy 数 / ジャグ配列
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/031_grundy_fast.rs
