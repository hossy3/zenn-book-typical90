---
title: "063 - Monochromatic Subgrid（★4）"
---

[063 \- Monochromatic Subgrid（★4）](https://atcoder.jp/contests/typical90/tasks/typical90_bk)


# アルゴリズム

## 問題を読む

入力例 1 から 1行減らした問題を考えます。

||||||||
|---|---|---|---|---|---|---|
||1|1|1|1|1|2|
||1|2|2|2|2|2|
||1|2|2|3|2|3|


この中でいくつかの行と列を選択します。すべて同じ数字になるところを、良い部分グリッドと呼びます。

たとえば以下が良い部分グリッドの例です。

||⬇️|⬇️|⬇️|⬇️|⬇️||
|---|---|---|---|---|---|---|
|➡|✅1|✅1|✅1|✅1|✅1|2|
||1|2|2|2|2|2|
||1|2|2|3|2|3|

||⬇️||||||
|---|---|---|---|---|---|---|
|➡|✅1|1|1|1|1|2|
|➡|✅1|2|2|2|2|2|
|➡|✅1|2|2|3|2|3|

|||⬇️|⬇️||⬇️||
|---|---|---|---|---|---|---|
||1|1|1|1|1|2|
|➡|1|✅2|✅2|2|✅2|2|
|➡|1|✅2|✅2|3|✅2|3|

一番下の例の 6個が、良い部分グリッドの最大値となります。

行の数が 8以下という制約がついています。


## 全探索


各行を選択したときに、選択した行すべてが同じ値になるかを、全探索で調べます。行の数が 8 以下という制約から、全探索が適していそうです。

次の表は、各行を選択した場合に、最大の良い部分グリッドの大きさを示しています。

|||1<br />1<br />1|1<br />2<br />2|1<br />2<br />2|1<br />2<br />3|1<br />2<br />2|2<br />2<br />3|最大数|
|---|---|---|---|---|---|---|---|---|
|1|⭕<br />✖️<br />✖️|✅1|✅1|✅1|✅1|✅1|2|1 * 5 = 5|
|2|✖️<br />⭕<br />✖️|1|✅2|✅2|✅2|✅2|✅2|1 * 5 = 5|
|3|⭕<br />⭕<br />✖️|✅1|-|-|-|-|-|2 * 1 = 2|
|4|✖️<br />✖️<br />⭕|1|✅2|✅2|3|✅2|3|1 * 3 = 3|
|5|⭕<br />✖️<br />⭕|✅1|-|-|-|-|-|2 * 1 = 2|
|6|✖️<br />⭕<br />⭕|1|✅2|✅2|-|✅2|-|2 * 3 = 6|
|7|⭕<br />⭕<br />⭕|✅1|-|-|-|-|-|3 * 1 = 1|

行の高さ h に対して、$1\le i<2^h$ の範囲で bit 全探索します。

各行で一番多く現れる数字が何になるかというのは、`HashMap` などを使って簡単に調べられます。

```rust
let mut m = HashMap::<usize, usize>::new();
for j in 0..w {
    if let Some(max) = f(&p, b, j) {
        *m.entry(max).or_insert(0) += 1;
    }
}
let col_count = m.values().max().unwrap_or(&0);
```

`*m.entry(key).or_insert(0)` は、マップにキーが存在しない場合に `0` を挿入し、存在する場合はその値を更新する便利な書き方です。 C++ で `m[key] += 1;` すると、マップにキーがないときにデフォルト値が入るのと同じです。次のように書き換えることもできます。

```rust
// *m.entry(max).or_insert(0) += 1; と同じ動き
if let Some(val) = m.get_mut(&key) {
    *val += 1;
} else {
    m.insert(key, 1);
}
```


# Tips

## 2次元配列の転置

今回の問題では、2次元配列の `p[i][j]` の i を動かして j を固定する調べ方をしていました。

- `p[0][0]`, `p[1][0]`, ..., `p[7][0]` が ✖️⭕⭕条件を満たすか
- `p[0][1]`, `p[1][1]`, ..., `p[7][1]` が ✖️⭕⭕条件を満たすか
- :
- `p[0][5]`, `p[1][5]`, ..., `p[7][5]` が ✖️⭕⭕条件を満たすか

条件を満たすか調べる処理を関数化すると、 `p` 2次元配列全体と、 `j` 列番号を渡すことになります。欲しいのは 1列だけなのに。

```rust
fn f(p: &[Vec<usize>], b: u8, j: usize) -> Option<usize> {
    let h = p.len();
    let mut val = None;
    for i in 0..h {
        let x = p[i][j];
        if b.bit_test(i) {
            if val.is_some_and(|x0| x0 != x) {
                return None;
            }
            val = Some(x);
        }
    }
    val
}
```

これを解消するために、事前に行と列を転置してみます。

```rust
let mut t = vec![vec![0usize; h]; w];
for i in 0..h {
    for j in 0..w {
        t[j][i] = p[i][j];
    }
}
```

条件の i, j が入れ替わります。

- `t[0][0]`, `t[0][1]`, ..., `t[0][7]` が ✖️⭕⭕条件を満たすか
- `t[1][0]`, `t[1][1]`, ..., `t[1][7]` が ✖️⭕⭕条件を満たすか
- :
- `t[5][0]`, `t[5][1]`, ..., `t[5][7]` が ✖️⭕⭕条件を満たすか

`p` 全体ではなく `t[i]` を判定関数に渡すと良くなります。少しスッキリします。

```diff rust
-fn f(p: &[Vec<usize>], b: u8, j: usize) -> Option<usize> {
-    let h = p.len();
-    let mut val = None;
-    for i in 0..h {
-        let x = p[i][j];
+fn f(t: &[usize], b: u8) -> Option<usize> {
+    let mut val = None;
+    for (i, &x) in t.iter().enumerate() {
         if b.bit_test(i) {
             if val.is_some_and(|x0| x0 != x) {
                 return None;
             }
             val = Some(x);
         }
     }
     val
 }
```

## Option 派と特別な数字派
|||1<br />1<br />1|1<br />2<br />2|1<br />2<br />2|1<br />2<br />3|1<br />2<br />2|2<br />2<br />3|最大数|
|---|---|---|---|---|---|---|---|---|
|3|⭕<br />⭕<br />✖️|✅1|-|-|-|-|-|2 * 1 = 2|
> - `p[0][0]`, `p[1][0]`, ..., `p[7][0]` が ✖️⭕⭕条件を満たすか

先ほどの関数は、条件を満たさないときに `None` を返すようにしていました。

代わりに、条件を満たさない場合は特別な数字 `0` を返す方法もあります。

|||1<br />1<br />1|1<br />2<br />2|1<br />2<br />2|1<br />2<br />3|1<br />2<br />2|2<br />2<br />3|最大数|
|---|---|---|---|---|---|---|---|---|
|3|⭕<br />⭕<br />✖️|✅1|0|0|0|0|0|2 * 1 = 2|


```diff
-fn f(t: &[usize], b: u8) -> Option<usize> {
-    let mut val = None;
+fn f(t: &[usize], b: u8) -> usize {
+    let mut val = 0;
     for (i, &x) in t.iter().enumerate() {
         if b.bit_test(i) {
-            if val.is_some_and(|x0| x0 != x) {
-                return None;
-            }
-            val = Some(x);
+            if val > 0 && val != x {
+                return 0;
+            }
+            val = x;
         }
     }
     val
 }
```

関数の呼び出し元で、0 が返ってくれば条件を満たさなかったと見分ければ良いです。

私は Rust では `Option<usize>` を使うのが好みです。特別な数字 0 や usize::MAX を使うと、関数の呼び出し元で混乱しがちです。これを避けられます。


# 実装例

## 全探索
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/063_full_search_2.rs

## 全探索 行列反転
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/063_full_search_1.rs

