---
title: "045 - Simple Grouping（★6）"
---

[045 \- Simple Grouping（★6）](https://atcoder.jp/contests/typical90/tasks/typical90_as)


# アルゴリズム

## 例題

公式入力例2 にある 5つの点を、3つのグループに分けることを考えます。各グループ内の距離の最大値をもっとも小さくします。

|i|(x, y)|
|---|---|
|0|(0, 0)|
|1|(1, 1)|
|2|(0, 2)|
|3|(2, 3)|
|4|(3, 1)|

次のようにグループ化すると、各グループ内の距離の最大値が 2 と、もっとも小さくなります。

```
    🔷3
🔴2
  🟩1 🟩4
🔴0
```

## 2点間の距離の二乗を求める

$(x_0, y_0)$ と $(x_1, y_1)$ の距離は $\sqrt{(x_1 - x_0)^2 + (y_1 - y_0)^2}$ で求まります。

√ があると実数演算になります。誤差と戦うことになってしまいます。二乗して整数演算だけで考えられるようにしておきます。

```rust
let mut dist = vec![vec![0; n]; n];
for (i0, &(x0, y0)) in xy.iter().enumerate() {
    for (i1, &(x1, y1)) in xy.iter().enumerate() {
        dist[i0][i1] = x1.abs_diff(x0).pow(2) + y1.abs_diff(y0).pow(2);
    }
}
```

|i|(x, y)|0|1|2|3|4|
|---|---|---|---|---|---|---|
|0|(0, 0)|0|2|4|13|10|
|1|(1, 1)|2|0|2|5|4|
|2|(0, 2)|4|2|0|5|10|
|3|(2, 3)|13|5|5|0|5|
|4|(3, 1)|10|4|10|5|0|

## すべてのグループ候補の距離最大値を求める

5つの要素で作られるグループの個数は、それぞれの要素が「含まれる」「含まれない」の 2通りありますので、計 $2^5=32$ 個となります。

要素0 と 要素2 を含むグループを、2進数で `0b00101` = グループ番号5 と考えます。

「要素 0, 2」「要素1, 4」「要素 3」の組み合わせは、2進数でグループ番号 `0b00101`,  `0b10010`,  `0b01000` に対応します。3つのグループ番号を 2進数で見ると、各桁の `1` が 1回ずつ現れるような組み合わせとなります。

要素数 1 のグループの最大距離は 0 です。

```rust
let mut cost = vec![0usize; 1 << n];
for i in 0..(1 << n) {
    for j0 in 0..n {
        for j1 in 0..j0 {
            if i.bit_test(j0) && i.bit_test(j1) {
                cost[i] = cost[i].max(dist[j0][j1]);
            }
        }
    }
}
```

|番号|2進数|グループ要素|最大距離|
|---|---|---|---|
|0|00000|[]|0|
|1|00001|[0]|0|
|2|00010|[1]|0|
|3|00011|[0, 1]|2|
|4|00100|[2]|0|
|5|00101|[0, 2]|4|
|6|00110|[1, 2]|2|
|7|00111|[0, 1, 2]|4|
|8|01000|[3]|0|
|9|01001|[0, 3]|13|
|10|01010|[1, 3]|5|
|11|01011|[0, 1, 3]|13|
|12|01100|[2, 3]|5|
|13|01101|[0, 2, 3]|13|
|14|01110|[1, 2, 3]|5|
|15|01111|[0, 1, 2, 3]|13|
|16|10000|[4]|0|
|17|10001|[0, 4]|10|
|18|10010|[1, 4]|4|
|19|10011|[0, 1, 4]|10|
|20|10100|[2, 4]|10|
|21|10101|[0, 2, 4]|10|
|22|10110|[1, 2, 4]|10|
|23|10111|[0, 1, 2, 4]|10|
|24|11000|[3, 4]|5|
|25|11001|[0, 3, 4]|13|
|26|11010|[1, 3, 4]|5|
|27|11011|[0, 1, 3, 4]|13|
|28|11100|[2, 3, 4]|10|
|29|11101|[0, 2, 3, 4]|13|
|30|11110|[1, 2, 3, 4]|10|
|31|11111|[0, 1, 2, 3, 4]|13|


## bit-DP ですべての組み合わせを調べる

グループ番号 13 = `0b01101` の最大距離は 13 です。これをもう 1グループ増やして、最大距離を減らすことを考えます。

グループ番号 `0b01101` を 2つに分けると、 `(0b00001, 0b01010)`, `(0b00100, 0b01001)`, `(0b00101, 0b01000)` になります。グループ 1つの場合の `0b01010` などの最大距離が分かっていれば、グループ 2つにした場合の最大距離も求められます。

グループ番号 13 を 2つに分けるすべての候補は、 0 + 13, 1 + 12, 2 + 11, 3 + 10, ... のように 13 以下の数を順に調べ、無関係な `0b00010` が含まれないものを除けば良いです。

これを繰り返して、3グループに分割したあとにすべてのビットが立っている `dp[3][0b11111]` を調べれば、これが答えになります。

`dp[1]` は `cost` と同じです。

```rust
let mut dp = vec![vec![usize::MAX; 1 << n]; k + 1];
dp[0][0] = 0;
for i in 0..k {
    for j0 in 0..(1 << n) {
        // j0 を j1 と j2 に分割
        for j1 in 0..=j0 {
            if j1 & j0 != j1 {
                continue;
            }
            let j2 = j0 ^ j1; // j0 - j1 でも同じ
            let x = dp[i][j2].max(cost[j1]);
            dp[i + 1][j0] = dp[i + 1][j0].min(x);
        }
    }
}
```

|番号|2進数|グループ要素|dp[0]|dp[1]|dp[2]|dp[3]|
|---|---|---|---|---|---|---|
|0|00000|[]|0|0|0|0|
|1|00001|[0]|-|0|0|0|
|2|00010|[1]|-|0|0|0|
|3|00011|[0, 1]|-|2|0|0|
|4|00100|[2]|-|0|0|0|
|5|00101|[0, 2]|-|4|0|0|
|6|00110|[1, 2]|-|2|0|0|
|7|00111|[0, 1, 2]|-|4|2|0|
|8|01000|[3]|-|0|0|0|
|9|01001|[0, 3]|-|13|0|0|
|10|01010|[1, 3]|-|5|0|0|
|11|01011|[0, 1, 3]|-|13|2|0|
|12|01100|[2, 3]|-|5|0|0|
|13|01101|[0, 2, 3]|-|13|4|0|
|14|01110|[1, 2, 3]|-|5|2|0|
|15|01111|[0, 1, 2, 3]|-|13|4|2|
|16|10000|[4]|-|0|0|0|
|17|10001|[0, 4]|-|10|0|0|
|18|10010|[1, 4]|-|4|0|0|
|19|10011|[0, 1, 4]|-|10|2|0|
|20|10100|[2, 4]|-|10|0|0|
|21|10101|[0, 2, 4]|-|10|4|0|
|22|10110|[1, 2, 4]|-|10|2|0|
|23|10111|[0, 1, 2, 4]|-|10|4|2|
|24|11000|[3, 4]|-|5|0|0|
|25|11001|[0, 3, 4]|-|13|5|0|
|26|11010|[1, 3, 4]|-|5|4|0|
|27|11011|[0, 1, 3, 4]|-|13|5|2|
|28|11100|[2, 3, 4]|-|10|5|0|
|29|11101|[0, 2, 3, 4]|-|13|5|4|
|30|11110|[1, 2, 3, 4]|-|10|5|2|
|31|11111|[0, 1, 2, 3, 4]|-|13|5|4|

しかし残念ながら、この方法では TLE します。

## bit の部分集合の列挙を効率化

先ほどの方法では、グループ番号 13 を 2つに分けるすべての候補を調べるときに、 0 + 13, 1 + 12, 2 + 11, 3 + 10, ... のように 13 以下の数を順に調べ、2, 3 のように無関係な `0b00010` を含む数字をはじいていました。これは効率が良くないです。

13以下の `0b01101` に含まれるビットの値を列挙するには、13 から 1ずつ引き算して `0b01101` との論理和を取る操作を繰り返すと、より効率的です。


|番号|2進数|1引く|& `01101` = 次の値|
|---|---|---|---|
|13|01101|01100|01100|
|12|01100|01011|01001|
|9|01001|01000|01000|
|8|01000|00111|00101|
|5|00101|00100|00100|
|4|00100|00011|00001|
|1|00001|00000|00000|
|0|00000|||

```diff rust
 // j0 を j1 と j2 に分割
-for j1 in 0..=j0 {
-    if j1 & j0 != j1 {
-        continue;
-    }
+let mut j1 = j0;
+loop {
     let j2 = j0 ^ j1; // j0 - j1 でも同じ
     let x = dp[i][j2].max(cost[j1]);
     dp[i + 1][j0] = dp[i + 1][j0].min(x);
+    if j1 == 0 {
+        break;
+    }
+    j1 = (j1 - 1) & j0;
 }
```

これで制限時間内に AC できます。

### 部分集合列挙の Iterator

この部分集合列挙をよく行いそうなら、 Iterator にするのも良いと思います。

```diff rust
 // j0 を j1 と j2 に分割
-let mut j1 = j0;
-loop {
+for j1 in bit_subset(j0) {
     let j2 = j0 ^ j1; // j0 - j1 でも同じ
     let x = dp[i][j2].max(cost[j1]);
     dp[i + 1][j0] = dp[i + 1][j0].min(x);
-    if j1 == 0 {
-        break;
-    }
-    j1 = (j1 - 1) & j0;
 }
```

```rust
struct BitSubset {
    start: usize,
    next: Option<usize>,
}

impl Iterator for BitSubset {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        let cur = self.next;
        if let Some(x) = self.next {
            self.next = if x > 0 {
                Some((x - 1) & self.start)
            } else {
                None
            };
        }
        cur
    }
}

fn bit_subset(start: usize) -> BitSubset {
    BitSubset {
        start,
        next: Some(start),
    }
}
```

# 実装例

## bit-DP (TLE)
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/045_bit_dp_tle.rs

## bit-DP + 部分集合の列挙を効率化
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/045_bit_dp_subset_2.rs

## bit-DP + 部分集合の列挙 Iterator
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/045_bit_dp_subset.rs
