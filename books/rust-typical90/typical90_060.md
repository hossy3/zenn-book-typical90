---
title: "060 - Chimera（★5）"
---

[060 \- Chimera（★5）](https://atcoder.jp/contests/typical90/tasks/typical90_bh)


# アルゴリズム


## 例題

例題 `[1, 4, 2, 8, 5, 7]` について、数字の並びが山形になるような組を考えます。

|$i$|$A_i$|採用?|棒グラフ|
|---|---|---|---|
|1|1||🟧|
|2|4||🟧🟧🟧🟧|
|3|2||🟧🟧|
|4|8||🟧🟧🟧🟧🟧🟧🟧🟧|
|5|5||🟧🟧🟧🟧🟧|
|6|7||🟧🟧🟧🟧🟧🟧🟧|

を

|$i$|$A_i$|採用?|棒グラフ|
|---|---|---|---|
|1|1|✅|🟧|
|2|4|❌|⬜⬜⬜⬜|
|3|2|✅|🟧🟧|
|4|8|✅|🟧🟧🟧🟧🟧🟧🟧🟧|
|5|5|✅|🟧🟧🟧🟧🟧|
|6|7|❌|⬜⬜⬜⬜⬜⬜⬜|

や

|$i$|$A_i$|採用?|棒グラフ|
|---|---|---|---|
|1|1|✅|🟧|
|2|4|✅|🟧🟧🟧🟧|
|3|2|❌|⬜⬜|
|4|8|✅|🟧🟧🟧🟧🟧🟧🟧🟧|
|5|5|❌|⬜⬜⬜⬜⬜|
|6|7|✅|🟧🟧🟧🟧🟧🟧🟧|

や

|$i$|$A_i$|採用?|棒グラフ|
|---|---|---|---|
|1|1|✅|🟧|
|2|4|❌|⬜⬜⬜⬜|
|3|2|✅|🟧🟧|
|4|8|❌|⬜⬜⬜⬜⬜⬜⬜⬜|
|5|5|✅|🟧🟧🟧🟧🟧|
|6|7|✅|🟧🟧🟧🟧🟧🟧🟧|

のようにします。最後の例もアリです。

山形を考えるのは難しいのです。先に、最後の例のように増え続ける棒グラフを考えます。

## LIS (最長増加部分列, longest increasing subsequence)

数が増え続けるように一番効率の良い並び方を考えます。 説明の都合上、2回繰り返す `[1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7]` について考えます。

|$i$|$A_i$|最適な並び|⚡の位置 = LIS|
|---|---|---|---|
|1|1|[⚡1]|1|
|2|4|[1, ⚡4]|2|
|3|2|[1, ⚡2]|2|
|4|8|[1, 2, ⚡8]|3|
|5|5|[1, 2, ⚡5]|3|
|6|7|[1, 2, 5, ⚡7]|4|
|7|1|[⚡1, 2, 5, 7]|1|
|8|4|[1, 2, ⚡4, 7]|3|
|9|2|[1, ⚡2, 4, 7]|2|
|10|8|[1, 2, 4, 7, ⚡8]|5|
|11|5|[1, 2, 4, ⚡5, 8]|4|
|12|7|[1, 2, 4, 5, ⚡7]|5|

配列 `[1]` に対して、昇順に並ぶ最適な配列を取り出すと `[1]` です。

配列 `[1, 4]` に対して、昇順に並ぶ最適な配列を取り出すと `[1, 4]` です。`[1]` や `[4]` は長さが少ないです。

配列 `[1, 4, 2]` に対して、昇順に並ぶ最適な配列を取り出すと `[1, 2]` です。 `[1, 4]` も同じ長さですが、次のことを考えると良くないです。`[1, 2]` は次に `3` が来た時に `[1, 2, 3]` とできます。 `[1, 4, 3]` はできません。

このように、元の入力配列を 1つ右に辿るたびに、数が増え続ける最適な配列を更新し続けてます。

* 最適な配列の値に `x` 以上の値が含まれていれば、その中で一番左の値を `x` に差し替える
* 最適な配列の値がすべて `x` 未満なら、右端に `x` を追加する

この更新した場所 ⚡ の列 `[1, 2, 2, 3, 3, 4, 1, ...]` が LIS の結果になります。

最適な配列は途中でも昇順に並んでいますので、二分探索で求められます。たとえば次のように行います。

```rust
/// longest increasing subsequence
fn lis(a: &[usize]) -> Vec<usize> {
    let mut v = vec![0; a.len()];
    let mut p = vec![];

    for (i, &x) in a.iter().enumerate() {
        let j = p.partition_point(|&y| y < x);
        if j == p.len() {
            p.push(x);
        } else if p[j] > x {
            p[j] = x;
        }
        v[i] = j + 1;
    }
    v
}
```

## 降順の部分列

`[1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7]` から昇順な部分列を求めました。

次に降順な部分列を求めます。左右反転した `[7, 5, 8, 2, 4, 1, 7, 5, 8, 2, 4, 1]` に対して昇順な部分列を求めれば良いです。

|$i$|$A_i$|最適な並び|⚡の位置 = LIS|
|---|---|---|---|
|1|7|[⚡7]|1|
|2|5|[⚡5]|1|
|3|8|[5, ⚡8]|2|
|4|2|[⚡2, 8]|1|
|5|4|[2, ⚡4]|2|
|6|1|[⚡1, 4]|1|
|7|7|[1, 4, ⚡7]|3|
|8|5|[1, 4, ⚡5]|3|
|9|8|[1, 4, 5, ⚡8]|4|
|10|2|[1, ⚡2, 5, 8]|2|
|11|4|[1, 2, ⚡4, 8]|3|
|12|1|[⚡1, 2, 4, 8]|1|

## 山型に組み合わせる

2つの最適な配列をつなぎ合わせると次のようになります。

||1|4|2|8|5|7|
|---|---|---|---|---|---|---|
|昇順|1<br />`[1]`|2<br />`[1, 4]`|2<br />`[1, 2]`|3<br />`[1, 2, 8]`|3<br />`[1, 2, 5]`|4<br />`[1, 2, 5, 7]`|
|降順|1<br />`[1]`|2<br />`[4, 2]`|1<br />`[2]`|2<br />`[8, 7]`|1<br />`[5]`|1<br />`[7]`|
|昇順+降順|2|4|3|5|4|5|

合計が大きな 5 を棒グラフにします。

|$i$|$A_i$|採用?|棒グラフ|
|---|---|---|---|
|昇順 1|1|✅|🟧|
|昇順 2|4|❌|⬜⬜⬜⬜|
|昇順 3|2|✅|🟧🟧|
|昇順 4<br />降順 3|8|✅|🟧🟧🟧🟧🟧🟧🟧🟧<br />🟨🟨🟨🟨🟨🟨🟨🟨|
|降順 2|5|✅|🟨🟨🟨🟨🟨|
|降順 1|7|❌|⬜⬜⬜⬜⬜⬜⬜|

|$i$|$A_i$|採用?|棒グラフ|
|---|---|---|---|
|昇順 1|1|✅|🟧|
|昇順 2|4|❌|⬜⬜⬜⬜|
|昇順 3|2|✅|🟧🟧|
|昇順 4|8|❌|⬜⬜⬜⬜⬜⬜⬜⬜|
|昇順 5|5|✅|🟧🟧🟧🟧🟧|
|昇順 6<br />降順 1|7|✅|🟧🟧🟧🟧🟧🟧🟧<br />🟨🟨🟨🟨🟨🟨🟨|

一番大きな値が2回現れます。そのため LIS の値を合計して 1 引くと、山型の数になります。

```rust
    let count = iter::zip(v0, v1).map(|(x0, x1)| x0 + x1 - 1).max().unwrap();
    println!("{count}");
```

このようにすると、


# 実装例

## LIS
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/060_lis.rs

