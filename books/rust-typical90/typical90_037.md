---
title: "037 - Don't Leave the Spice（★5）"
---

[037 \- Don't Leave the Spice（★5）](https://atcoder.jp/contests/typical90/tasks/typical90_ak)


# 問題

例題1 の各数字を 10で割ったものを考えます。解説の都合で、最後の香辛料だけは多く使っても良いものとします。

```
10 4
3 4 12
3 4 3
3 4 150
3 6 4
```


# アルゴリズム
## DP

|香辛料|最小|最大|価値|
|---|---|---|---|
|香辛料 1|3|4|12|
|香辛料 2|3|4|3|
|香辛料 3|3|4|150|
|香辛料 4|3|6|6|

||0|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|---|
|初期|0|-|-|-|-|-|-|-|-|-|-|
|香辛料 1まで|0|-|-|⚡12|⚡12|-|-|-|-|-|-|
|香辛料 2まで|0|-|-|12|12|-|⚡15|⚡15|⚡15|-|-|
|香辛料 3まで|0|-|-|⚡150|⚡150|-|⚡162|⚡162|-|⚡165|⚡165|
|香辛料 4まで|0|-|-|150|150|⚡4|162|162|⚡154|⚡166|⚡166|

香辛料を1つ追加するたびに、その香辛料まで使ったときの香辛料の合計重さと最大価値の対応を更新します。小数は考えなくて良いです。

香辛料をすべて使い終わった後の、10mg 使った時の価値 166 が答えになります。

この表をどうやって更新するか、という問題になります。

ハイフンは到達しない値です。評価 -∞ に相当する `i64::MIN` などを入れておきます。

## 貰う DP / スライド最小値(最大値) 簡易版

香辛料 3 までの表が確定しているときに、香辛料 4 までの表を作ることを考えます。

|0|1|2|3|4|5|6|7|8|9|10|状態|最大価値|次の値|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|🔍0|-|-|📝150|150|-|162|162|-|165|165|{(0,0)}|0|150|
|🔍0|🔍|-|150|📝150|-|162|162|-|165|165|{(-,1)<br>(0,0)}|0|150|
|🔍0|🔍-|🔍-|150|150|📝-|162|162|-|165|165|{(-,2)<br>(-,1)<br>(0,0)}|0|⚡4|
|🔍0|🔍-|🔍-|🔍150|150|-|📝162|162|-|165|165|{(-,2)<br>(-,1)<br>(0,0)<br>(150,3)}|150|162|
|0|🔍-|🔍-|🔍150|🔍150|-|162|📝162|-|165|165|{(-,2)<br>(-,1)<br>(150,3)<br>(150,4)}|150|162|
|0|-|🔍-|🔍150|🔍150|🔍-|162|162|📝-|165|165|{(-,2)<br>(-,5)<br>(150,3)<br>(150,4)}|150|⚡154|
|0|-|-|🔍150|🔍150|🔍-|🔍162|162|-|📝165|165|{(-,5)<br>(150,3)<br>(150,4)<br>(162,6)}|162|⚡166|
|0|-|-|150|🔍150|🔍-|🔍162|🔍162|-|165|📝165|{(-,5)<br>(150,4)<br>(162,6)<br>(162,7)}|162|⚡166|

範囲の状態を `BTreeSet` 内に溜めておきます。そうすると、最大値は `set.last()` で、それぞれ $O(log W)$ で求まります。

次のしゃくとり法のようなコードになります。

```rust
let mut set = BTreeSet::new();
for i in l..=w {
    set.insert((prev[i - l], i - l));
    if i > r {
        set.remove(&(prev[i - r - 1], i - r - 1));
    }
    let &(x, _) = set.last().unwrap();
    dp[i] = prev[i].max(x + v);
}
```

これでも十分な速度で回答できます。

## 貰う DP / スライド最小値(最大値)

先ほどは `set` に候補すべての状態を溜めていました。新しい候補が大きな値の場合は、もう使わない値も出てきます。

たとえば `{(-, 2), (-, 1), (0, 0)}` の次に `(150, 3)` が現れた場合を考えます。それより小さな前 3つの値を使うことはありません。 `(150, 3)` 以外は忘れて良いです。

これを効率的に扱うため、状態を、配列の前後から追加しやすい構造 `deque` `VecDeque` で持つようにします。

* 値の追加
  * `deque` の右端が今回追加したい値以下の場合は、その値はもう使わないものとして取り除きつづけます
  * 上の操作が終わった後、今回の (値, インデックス) の組を追加します
* 値の削除
  * 左端が範囲から外れたインデックスの場合は、取り除きます

|0|1|2|3|4|5|6|7|8|9|10|状態|最大価値|新しい値|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|🔍0|-|-|📝150|150|-|162|162|-|165|165|[(0,0)]|0|150|
|🔍0|🔍|-|150|📝150|-|162|162|-|165|165|[(0,0)<br>(-,1)]|0|150|
|🔍0|🔍-|🔍-|150|150|📝-|162|162|-|165|165|[(0,0)<br>(-,1)]|0|⚡4|
|🔍0|🔍-|🔍-|🔍150|150|-|📝162|162|-|165|165|[(150,3)]|150|162|
|0|🔍-|🔍-|🔍150|🔍150|-|162|📝162|-|165|165|[(150,4)]|150|162|
|0|-|🔍-|🔍150|🔍150|🔍-|162|162|📝-|165|165|[(150,4)<br>(-,5)]|150|⚡154|
|0|-|-|🔍150|🔍150|🔍-|🔍162|162|-|📝165|165|[(162,6)]|162|⚡166|
|0|-|-|150|🔍150|🔍-|🔍162|🔍162|-|165|📝165|[(162,7)]|162|⚡166|

値はインデックスがあれば分かります。`deque` でインデックスだけを管理することが多いです。

値が降順に並びます。最大の値は `deque[0]` を見れば分かります。1回の問い合わせあたり $O(1)$ で求まります。

```rust
let mut queue = VecDeque::<usize>::new();
for i in l..=w {
    while let Some(&j) = queue.back() {
        if prev[j] > prev[i - l] {
            break;
        }
        queue.pop_back();
    }
    queue.push_back(i - l);
    if i > r && queue[0] == i - r - 1 {
        queue.pop_front();
    }
    let x = prev[queue[0]];
    dp[i] = prev[i].max(x + v);
}
```

## 貰う DP / セグメント木

セグメント木を使うと、自前で状態管理しなくても 1回の問い合わせあたり $O(log W)$ で区間の最大値を得られます。

同じ香辛料を 2回使わないように、後ろから状態を更新します。

|0|1|2|3|4|5|6|7|8|9|10|最大価値|新しい値|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
|0|-|-|150|🔍150|🔍-|🔍162|🔍162|-|165|📝165|162|⚡166|
|0|-|-|🔍150|🔍150|🔍-|🔍162|162|-|📝165|166|162|⚡166|
|0|-|🔍-|🔍150|🔍150|🔍-|162|162|📝-|166|166|150|⚡154|
|0|🔍-|🔍-|🔍150|🔍150|-|162|📝162|154|166|166|150|162|
|🔍0|🔍-|🔍-|🔍150|150|-|📝162|162|154|166|166|150|162|
|🔍0|🔍-|🔍-|150|150|📝-|162|162|154|166|166|0|⚡4|
|🔍0|🔍|-|150|📝150|4|162|162|154|166|166|0|150|
|🔍0|-|-|📝150|150|4|162|162|154|166|166|0|150|

```rust
let mut segtree = Segtree::<Max<i64>>::new(w + 1);
segtree.set(0, 0);

for (l, r, v) in lrv {
    for i in (l..=w).rev() {
        let l0 = i.saturating_sub(r);
        let r0 = i - l;
        let x = segtree.prod(l0..=r0);
        if x >= 0 {
            segtree.set(i, segtree.get(i).max(x + v));
        }
    }
}
```

区間の左端が 0 を下回らないように `i.saturating_sub(r);` 0 で打ち切るようにしました。 `if i >= r { i - r } else { 0 };` と同じです。


## 配る DP / 遅延セグメント木

遅延セグメント木でも一応時間内に解けます。

|0|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
|0|-|-|150|150|-|162|🔍162|-|165|📝165<br>⚡166|
|0|-|-|150|150|-|🔍162|162|-|📝165<br>⚡166|📝166|
|0|-|-|150|150|🔍-|162|162|📝-|📝166|📝166|
|0|-|-|150|🔍150|-|162|162|📝-<br>⚡154|📝166|📝166|
|0|-|-|🔍150|150|-|📝162|📝162|📝154|📝166|166|
|0|-|🔍-|150|150|📝-|📝162|📝162|📝154|166|166|
|0|🔍|-|150|📝150|📝-|📝162|📝162|154|166|166|
|🔍0|-|-|📝150|📝150|📝-<br>⚡4|📝162|162|154|166|166|

```rust
struct MaxMax;
impl MapMonoid for MaxMax {
    type M = Max<i64>;
    type F = i64;

    fn identity_map() -> Self::F {
        i64::MIN
    }
    fn mapping(&f: &Self::F, &x: &<Self::M as Monoid>::S) -> <Self::M as Monoid>::S {
        f.max(x)
    }
    fn composition(&f: &Self::F, &g: &Self::F) -> Self::F {
        f.max(g)
    }
}
```

```rust
for i in (0..=(w - l)).rev() {
    let x = segtree.get(i);
    if x >= 0 {
        segtree.apply_range((i + l)..=w.min(i + r), x + v);
    }
}
```

# Tips

## デバッグに assert! を使う

```diff rust
 while let Some(&j) = queue.back() {
     if prev[j] > prev[i - l] {
         break;
     }
     queue.pop_back();
 }
 queue.push_back(i - l);
 if i > r && queue[0] == i - r - 1 {
     queue.pop_front();
 }
+for (i0, i1) in queue.iter().tuple_windows() {
+    assert!(i0 < i1);
+    assert!(prev[*i0] > prev[*i1]);
+}
 let x = prev[queue[0]];
 dp[i] = prev[i].max(x + v);
```

手元のテストケースは通過しても提出すると一部で失敗するときに、 `assert!` でその場で停止するコードを書くと、ヒントになることがあります。AtCoder では、誤った結果を出力したときの `WA` と、途中でコードが停止する `RE` が区別できるためです。

提出コードがこのチェックでタイムアウトしないように、提出前には消します。

私の場合、`if prev[j] > prev[i - l] {` を `if prev[j] > prev[i] {` と誤って書いていて、一部のテストケースが通りませんでした。 `assert!` を書くと見つかりました。


# 実装例

速度は 「スライド最小化」 $O(NW)$ ≫ $O(N W log W)$「スライド最小化 簡易版」 ≒ 「セグメント木」 >  です。

## スライド最小化 簡易版
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/037_sliding_window_btreeset.rs

## スライド最小化
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/037_sliding_window_deque.rs

## セグメント木
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/037_segtree.rs

## 遅延セグメント木
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/037_lazysegtree.rs

