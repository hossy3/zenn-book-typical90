---
title: "057 - Flip Flap（★6）"
---

[057 \- Flip Flap（★6）](https://atcoder.jp/contests/typical90/tasks/typical90_be)


# アルゴリズム

## 例題

4枚のパネルを操作する 5種類のスイッチを考えます。

|スイッチ|パネル反転|
|---|---|
|1|⚡⚡⚡⚡|
|2|⚡⚡⬜⬜|
|3|⬜⚡⚡⬜|
|4|⬜⬜⚡⚡|
|5|⚡⬜⬜⚡|

このスイッチをそれぞれ最大 1回使い、すべて消灯状態「⬜⬜⬜⬜」から、状態「💡⬜💡⬜」にする方法が何通りかを調べます。

* (1, 2, 5): 「⬜⬜⬜⬜」→「💡💡💡💡」→「⬜⬜💡💡」→「💡⬜💡⬜」
* (1, 3, 4): 「⬜⬜⬜⬜」→「💡💡💡💡」→「💡⬜⬜💡」→「💡⬜💡⬜」
* (2, 3): 「⬜⬜⬜⬜」→「💡💡⬜⬜」→「💡⬜💡⬜」
* (4, 5): 「⬜⬜⬜⬜」→「⬜⬜💡💡」→「💡⬜💡⬜」

4通りです。

すべて消灯状態「⬜⬜⬜⬜」から、状態「💡⬜⬜⬜」にする方法は存在しません。


## 掃き出し法

### スイッチを組み合わせるイメージ

もとのスイッチのまま考えるのは難しいです。

|スイッチ|パネル反転|
|---|---|
|1|⚡⚡⚡⚡|
|2|⚡⚡⬜⬜|

スイッチ 1 とスイッチ 2 で表せる光り方は 2*2 = 4通りです。

|スイッチ|パネル反転|
|---|---|
|-|⬜⬜⬜⬜|
|1|💡💡💡💡|
|2|💡💡⬜⬜|
|1, 2|⬜⬜💡💡|

スイッチ 2で一番左のパネルを反転しないように、「スイッチ 1 とスイッチ 2 を両方操作する」場合を「スイッチ 2' を操作する」と扱います。そうすると次のようになります。

|スイッチ|パネル反転|
|---|---|
|1|⚡⚡⚡⚡|
|2'|⬜⬜⚡⚡|

|スイッチ|パネル反転|
|---|---|
|-|⬜⬜⬜⬜|
|1|💡💡💡💡|
|2'|⬜⬜💡💡|
|1, 2'|💡💡⬜⬜|

スイッチ 1 とスイッチ 2' の両方を操作すると、もとのスイッチに戻すと スイッチ 2 を 2回操作したことになります。2回操作するのは 2回反転して元に戻ります。なにもしないことに相当します。

スイッチ2, スイッチ2' どちらを使っても、表せるパネルの組み合わせは同じです。それなら、複数のスイッチを組み合わせて扱いやすい形にしたいです。

### 左端のパネルを扱うスイッチを 1つにする

この問題のスイッチを、左からパネルを確定させやすいように組み立て直してみます。

|スイッチ|パネル反転|
|---|---|
|1|⚡⚡⚡⚡|
|2|⚡⚡⬜⬜|
|3|⬜⚡⚡⬜|
|4|⬜⬜⚡⚡|
|5|⚡⬜⬜⚡|

スイッチ 1 で、左端のパネルを反転できます。スイッチ 1「以外」も左端のパネルを反転できると、組み合わせを考えるのが難しくなります。スイッチ 1 以外 かつ 左端のパネルを反転するものについて、スイッチ 1 を適用し、左端のパネルを反転できないようにします。

|スイッチ|変更前|変更後|
|---|---|---|
|1|⚡⚡⚡⚡|⚡⚡⚡⚡|
|2|⚡⚡⬜⬜|⬜⬜⚡⚡|
|3|⬜⚡⚡⬜|⬜⚡⚡⬜|
|4|⬜⬜⚡⚡|⬜⬜⚡⚡|
|5|⚡⬜⬜⚡|⬜⚡⚡⬜|

これで、左端のパネルに関するスイッチが 1つになりました。次からは 1'～5' のスイッチを考えます。

|スイッチ||
|---|---|
|1'|⚡⚡⚡⚡|
|2'|⬜⬜⚡⚡|
|3'|⬜⚡⚡⬜|
|4'|⬜⬜⚡⚡|
|5'|⬜⚡⚡⬜|

### 左から 2番目のパネルを扱うスイッチを 1つにする

次に、「スイッチ 1' 以外で」 左から 2番目のパネルを扱うスイッチを 1つだけ残すようにします。スイッチ 3' です。

2' と 3' の場所を入れ替えます。

|スイッチ||
|---|---|
|1'|⚡⚡⚡⚡|
|3'|⬜⚡⚡⬜|
|2'|⬜⬜⚡⚡|
|4'|⬜⬜⚡⚡|
|5'|⬜⚡⚡⬜|

2行目以外で、左から 2番目のパネルを操作しているものに対して、先ほど同様に 2行目のスイッチをまとめて操作したことにします。

|スイッチ|変更前|変更後|
|---|---|---|
|1'|⚡⚡⚡⚡|⚡⬜⬜⚡|
|3'|⬜⚡⚡⬜|⬜⚡⚡⬜|
|2'|⬜⬜⚡⚡|⬜⬜⚡⚡|
|4'|⬜⬜⚡⚡|⬜⬜⚡⚡|
|5'|⬜⚡⚡⬜|⬜⬜⬜⬜|

これで、左から 2番目のパネルに関するスイッチが 1つになりました。次からは 1''～5'' のスイッチを考えます。

|スイッチ||
|---|---|
|1''|⚡⬜⬜⚡|
|2''|⬜⚡⚡⬜|
|3''|⬜⬜⚡⚡|
|4''|⬜⬜⚡⚡|
|5''|⬜⬜⬜⬜|

### 左から 3番目のパネルを扱うスイッチを 1つにする

次に、「スイッチ 1'', 2'' 以外で」 左から 3番目のパネルを扱うスイッチを 1つだけ残すようにします。スイッチ 3'' です。

他に左から 3番目のパネルを操作している 2'', 4'' について、まとめて操作したことにします。

|スイッチ|変更前|変更後|
|---|---|---|
|1''|⚡⬜⬜⚡|⚡⬜⬜⚡|
|2''|⬜⚡⚡⬜|⬜⚡⬜⚡|
|3''|⬜⬜⚡⚡|⬜⬜⚡⚡|
|4''|⬜⬜⚡⚡|⬜⬜⬜⬜|
|5''|⬜⬜⬜⬜|⬜⬜⬜⬜|

### 左から 4番目のパネルを扱うスイッチ

「スイッチ 1, 2, 3 以外で」 左から 4番目のパネルを扱うスイッチを 1つだけ残すようにしようと思います。

しかし、4行目以降にこのパネルに影響するスイッチはありません。スイッチ4, スイッチ5 は何もしません。

ここまでで整理完了です。

```rust
fn xor(a: &[bool], b: &[bool]) -> Vec<bool> {
    let v: Vec<_> = iter::zip(a, b).map(|(&a, &b)| a ^ b).collect();
    v
}

fn f(mut a: Vec<Vec<bool>>, mut b: Vec<bool>) -> usize {
    let n = a.len();
    let m = b.len();

    let mut pos = 0; // pos 以降の行列を整える
    for i in 0..m {
        let Some(j) = (pos..n).find(|&j| a[j][i]) else {
            continue;
        };
        a.swap(pos, j);

        for j in 0..n {
            if j != pos && a[j][i] {
                a[j] = xor(&a[j], &a[pos]);
            }
        }
        pos += 1;
    }

    // :
}
```

## 何通りかを調べる

### 消灯状態をスタートにする

|スイッチ||目的|
|---|---|---|
|1|⚡⬜⬜⚡|左から 1番目を光らせる|
|2|⬜⚡⬜⚡|左から 2番目を光らせる|
|3|⬜⬜⚡⚡|左から 3番目を光らせる|
|4|⬜⬜⬜⬜|何もしない|
|5|⬜⬜⬜⬜|何もしない|

変更後のスイッチをそれぞれ最大 1回使い、すべて消灯状態「⬜⬜⬜⬜」から、状態「💡⬜💡⬜」にする方法が何通りかを調べます。

左端のパネルを光らせるスイッチは 1番目だけ、左端から 3番目のパネルを光らせるスイッチは 3番目だけです。

|スイッチ||操作|結果|
|---|---|---|---|
||||⬜⬜⬜⬜|
|1|⚡⬜⬜⚡|On|💡⬜⬜💡|
|2|⬜⚡⬜⚡|Off|💡⬜⬜💡|
|3|⬜⬜⚡⚡|On|💡⬜💡⬜|
|4|⬜⬜⬜⬜|*|💡⬜💡⬜|
|5|⬜⬜⬜⬜|*|💡⬜💡⬜|

スイッチ1～3 は操作方法が決まっています。4, 5 は On/Off どちらでも良いです。 よって答えは $2^2=4$ 通りとなります。

すべて消灯状態「⬜⬜⬜⬜」から、状態「💡⬜⬜⬜」にはできません。同じように操作を行って右端のパネルを消せないためです。

|スイッチ||操作|結果|
|---|---|---|---|
||||⬜⬜⬜⬜|
|1|⚡⬜⬜⚡|On|💡⬜⬜💡|
|2|⬜⚡⬜⚡|Off|💡⬜⬜💡|
|3|⬜⬜⚡⚡|Off|💡⬜⬜💡|
|4|⬜⬜⬜⬜|*|💡⬜⬜💡|
|5|⬜⬜⬜⬜|*|💡⬜⬜💡|


### 消灯状態をゴールにする

スタートとゴールを入れ替えて考えることもできます。そうすると「光っていれば消す」「最後に全部消えれば OK」と、より簡単にコードを書けます。

|スイッチ||操作|結果|
|---|---|---|---|
||||💡⬜💡⬜|
|1|⚡⬜⬜⚡|On|⬜⬜💡💡|
|2|⬜⚡⬜⚡|Off|⬜⬜💡💡|
|3|⬜⬜⚡⚡|On|⬜⬜⬜⬜|
|4|⬜⬜⬜⬜|*|⬜⬜⬜⬜|
|5|⬜⬜⬜⬜|*|⬜⬜⬜⬜|

|スイッチ||操作|結果|
|---|---|---|---|
||||💡⬜⬜⬜|
|1|⚡⬜⬜⚡|On|⬜⬜⬜💡|
|2|⬜⚡⬜⚡|Off|⬜⬜⬜💡|
|3|⬜⬜⚡⚡|Off|⬜⬜⬜💡|
|4|⬜⬜⬜⬜|*|⬜⬜⬜💡|
|5|⬜⬜⬜⬜|*|⬜⬜⬜💡|

次のようなコードになります。

```rust
fn f(mut a: Vec<Vec<bool>>, mut b: Vec<bool>) -> usize {
    // :

    for a in &a[0..pos] {
        if let Some(i) = a.iter().position(|&x| x) {
            if b[i] {
                b = xor(a, &b);
            }
        }
    }

    let yes = b.iter().all(|&x| !x);
    if yes {
        let k = n - pos; // 残りはすべて 0。自由に選択できるはず
        let result = pow_mod(2, k as i64, 998244353) as usize;
        result
    } else {
        0
    }
}
```

掃き出し法でスイッチを整理しつつ、その場で消しても良いです。

```diff rust
 fn f(mut a: Vec<Vec<bool>>, mut b: Vec<bool>) -> usize {
     let n = a.len();
     let m = b.len();

     let mut pos = 0; // pos 以降の行列を整える
     for i in 0..m {
         let Some(j) = (pos..n).find(|&j| a[j][i]) else {
             continue;
         };
         a.swap(pos, j);

         for j in 0..n {
             if j != pos && a[j][i] {
                 a[j] = xor(&a[j], &a[pos]);
             }
         }
+        if b[i] {
+            b = xor(&b, &a[pos]);
+        }
         pos += 1;
     }
-
-    for a in &a[0..pos] {
-        if let Some(i) = a.iter().position(|&x| x) {
-            if b[i] {
-                b = xor(a, &b);
-            }
-        }
-    }

     let yes = b.iter().all(|&x| !x);
     if yes {
         let k = n - pos; // 残りはすべて 0。自由に選択できるはず
         let result = pow_mod(2, k as i64, 998244353) as usize;
         result
     } else {
         0
     }
 }
```

# 実装例

## 掃き出し法と組み立てを分けて行う
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/057_row_reduction_2.rs

## 掃き出し法と組み立てをまとめて行う
https://github.com/hossy3/atcoder-solutions/blob/main/atcoder/typical90/src/bin/057_row_reduction.rs
